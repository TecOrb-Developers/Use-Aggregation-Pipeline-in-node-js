/* eslint-disable no-empty-function */
/* eslint-disable no-fallthrough */
/* eslint-disable default-case */
/* eslint-disable no-inner-declarations */
import { mergeDeep, crossBrowserFocus } from '../util';
import FCAccessibilityExportEnabled from './exportEnabled';
import FCAccessibilityBase from './base';

let UNDEF;
class FCAccessibilityLegendEnabled extends FCAccessibilityExportEnabled {
  // eslint-disable-next-line no-useless-constructor
  constructor (svgRoot, chartInstance, alternateTexts, config) {
    super(svgRoot, chartInstance, alternateTexts, config);
  }

  /**
     * True if all plots are hidden by legend interaction as a result legends are also in disabled state
     * False otherwise
     */
  isAllLegendItemHidden () {
    let legend = this.chartInstance.apiInstance._components.legend;
    // Applies only for discrete legend
    if (legend && legend.length !== 0) {
      let legendItems = legend[0]._components.legendItem;
      if (!legendItems) return false;
      for (let i = 0; i < legendItems.length; i++) {
        if (legendItems[i]._legendState.indexOf('hidden') === -1) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  /**
     * Checks if all a specific legend items is diabled by legend interaction
     * @param {number} index
     */
  isLegendItemHidden (index) {
    let legendItems = this.chartInstance.apiInstance._components.legend && this.chartInstance.apiInstance._components.legend[0]._components.legendItem;
    if (!legendItems) return false;
    return legendItems[index]._legendState.indexOf('hidden') >= 0;
  }

  /**
     * Make chart legend accessible
     */
  makeLegendAccessible (bLegend) {
    let bindLegend = bLegend;
    (bindLegend === UNDEF) && (bindLegend = true);
    if (!bindLegend) {
      return;
    }
    var self = this;
    if (this.chartInstance.getChartAttribute('showlegend') !== '0') {
      // let legendRegion = this.svgRoot.querySelectorAll("g[class^=raphael][class$=legendGroup] > [class$=item]");
      // if(legendRegion && legendRegion.length > 0) {
      //     this.addTabIndexAndSetAria(legendRegion[0], null, null, "-1", "region");
      // }
      let legendTexts = this.svgRoot.querySelectorAll('g[class^=raphael][class$=legendGroup] > [class$=item] > text');
      if (legendTexts && legendTexts.length > 0) {
        let legendLength = legendTexts.length,
          legendIndex = -1;
        function legendSelectOnKeyPress (event) {
          let elem = this,
            keyCaptured = false;
          event.stopPropagation();
          switch (event.keyCode) {
            case 37:
              // left arrow
            case 38:
              // up arrow
              if (legendIndex > 0) {
                legendIndex = (+elem.getAttribute('pIndex')) - 1;
              }
              keyCaptured = true;
              break;
            case 39:
              // right arrow
            case 40:
              // down arrow
              if (legendIndex < legendLength - 1) {
                // ++legendIndex;
                legendIndex = (+elem.getAttribute('pIndex')) + 1;
              }
              keyCaptured = true;
              break;
            case 13:
              // Enter
            case 32:
              // spacebar
              legendIndex = +elem.getAttribute('pIndex');
              self.chartInstance.apiInstance._components.legend[0]._components.legendItem[legendIndex].fireEvent('fc-click');
              // @todo
              setTimeout(() => {
                self.makeMultiSeriesAccessible && self.makeMultiSeriesAccessible(false);
              }, 100);
              keyCaptured = true;
              break;
          }
          if (keyCaptured) {
            crossBrowserFocus(legendTexts[legendIndex]);
            event.preventDefault();
          }
        }

        for (let i = 0; i < legendTexts.length; i++) {
          let legendStat = {};
          legendStat['{legendText}'] = legendTexts[i].innerHTML;

          this.addTabIndexAndSetAria(legendTexts[i], this.alternateTexts.legendItem, mergeDeep(this.chartPropertyMap, legendStat), i === 0 ? '3' : '-1', 'button', { pIndex: i });
          legendTexts[i].removeEventListener('keydown', legendTexts[i].legendSelectOnKeyPress, false);
          legendTexts[i].legendSelectOnKeyPress = legendSelectOnKeyPress;
          legendTexts[i].addEventListener('keydown', legendTexts[i].legendSelectOnKeyPress, false);
        }

        /**
         * Handler for updating legend index on focus
         */
        function legendIndexUpdate () {
          legendIndex = 0;
        }
        // If first legend is focused by pressing tab then legendIndex will be zero
        legendTexts[0].addEventListener('focus', legendIndexUpdate);
      }
    }
  }

  /**
     * Function to make lower and upper sliders accessible for gradient legend
     */
  makeGradientLegendAccessible () {
    let legendSliders = this.svgRoot.querySelectorAll('g[class^=raphael][class$=fc-gl-slider]'),
      chartInstance = this.chartInstance,
      ariaLabelMethod = this.addTabIndexAndSetAria,
      alternateTexts = this.alternateTexts,
      chartPropertyMap = this.chartPropertyMap;
    if (legendSliders) {
      let legendStat = {},
        sliders,
        lowerSliderCurrentPos = 0,
        upperSliderCurrentPos = 0;
      // Lable for sliders
      legendStat['{lowerRangeLabel}'] = this.chartData.colorrange.startlabel;
      legendStat['{upperRangeLabel}'] = this.chartData.colorrange.endlabel;
      // Get the sliders element of Fusioncharts.
      sliders = chartInstance.apiInstance._components.gLegend[0].sGroup.sliders;

      legendStat['{rangeStart}'] = legendStat['{currentStartValue}'] = sliders['false'].rangeGroup.updateWhenInMove(sliders['false'], sliders['false'].currPos);
      legendStat['{rangeEnd}'] = legendStat['{currentEndValue}'] = sliders['true'].rangeGroup.updateWhenInMove(sliders['true'], sliders['true'].currPos);

      // Set aria-label for both the sliders
      this.addTabIndexAndSetAria(legendSliders[0], this.alternateTexts.lowerRange, mergeDeep(this.chartPropertyMap, legendStat), '3');
      this.addTabIndexAndSetAria(legendSliders[1], this.alternateTexts.upperRange, mergeDeep(this.chartPropertyMap, legendStat), '3');

      /**
             * Function to handle the movement of sliders on left/right arrow key press
             * @param {Object} event - the event object associated
             * @param {Number} index - index of the slider
             */
      function slideRangeOnKeyPress (event, index) {
        event.stopPropagation();
        let keyCode = event.keyCode,
          extremes = chartInstance.apiInstance._components.gLegend[0].sGroup.extremes,
          displacement = 0,
          currentPos = (index === 0) ? lowerSliderCurrentPos : upperSliderCurrentPos,
          keyCaptured = false,
          sliderRange = Math.floor(extremes[1] - extremes[0]),
          bothSlidersOverlapped = (sliderRange + upperSliderCurrentPos === lowerSliderCurrentPos),
          maxDisplacement = (index === 0) ? sliderRange : -sliderRange,
          self,
          newValue;
        if (index === 0) {
          self = chartInstance.apiInstance._components.gLegend[0].sGroup.sliders['false'];
        } else {
          self = chartInstance.apiInstance._components.gLegend[0].sGroup.sliders['true'];
        }
        switch (keyCode) {
          // Left arrow key
          case 37:
            if ((index === 0 && currentPos > 0) || (index === 1 && currentPos > maxDisplacement && !bothSlidersOverlapped)) {
              displacement = currentPos - sliderRange / 10;
              (index === 0) ? (lowerSliderCurrentPos = displacement) : (upperSliderCurrentPos = displacement);
              keyCaptured = true;
            }
            break;

            // Right arrow key
          case 39:
            if ((index === 0 && currentPos < maxDisplacement && !bothSlidersOverlapped) || (index === 1 && currentPos < 0)) {
              displacement = currentPos + sliderRange / 10;
              (index === 0) ? (lowerSliderCurrentPos = displacement) : (upperSliderCurrentPos = displacement);
              keyCaptured = true;
            }
            break;
        }

        newValue = self.rangeGroup.updateWhenInMove(self, self.currPos + displacement);
        // Update lower/upper range according to the sliders moved
        if (index === 0) {
          legendStat['{currentStartValue}'] = newValue;
        } else {
          legendStat['{currentEndValue}'] = newValue;
        }
        ariaLabelMethod(legendSliders[0], alternateTexts.lowerRange, mergeDeep(chartPropertyMap, legendStat), '3');
        ariaLabelMethod(legendSliders[1], alternateTexts.upperRange, mergeDeep(chartPropertyMap, legendStat), '3');

        if (keyCaptured) {
          // Call the dragAPI of the library
          let dragAPI;
          if (index === 0) {
            dragAPI = chartInstance.apiInstance._components.gLegend[0].sGroup.sliders['false'].getDragAPI();
          } else {
            dragAPI = chartInstance.apiInstance._components.gLegend[0].sGroup.sliders['true'].getDragAPI();
          }
          dragAPI.dragStart({ stopPropagation: function () {} });
          dragAPI.dragging({ stopPropagation: function () {}, data: [displacement] });
        }
      }

      // eslint-disable-next-line good-practices/no-anonymous-handler
      legendSliders[0].addEventListener('keydown', function (event) {
        slideRangeOnKeyPress(event, 0);
      });
      // eslint-disable-next-line good-practices/no-anonymous-handler
      legendSliders[1].addEventListener('keydown', function (event) {
        slideRangeOnKeyPress(event, 1);
      });
    }
  }
}

export { FCAccessibilityBase, FCAccessibilityLegendEnabled };

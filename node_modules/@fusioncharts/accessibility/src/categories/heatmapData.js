/* eslint-disable default-case */
import { mergeDeep, crossBrowserFocus } from '../util';
import { FCAccessibilityLegendEnabled } from './legendEnabled';

class FCAccessibilityHeatMap extends FCAccessibilityLegendEnabled {
  constructor (svgRoot, chartInstance, alternateTexts, config) {
    super(svgRoot, chartInstance, alternateTexts, config);

    this.addAxisInformation();
  }

  /**
     * Make multi series chart accessible
     */
  makeNestedDataAccessible () {
    let gLegend = this.chartInstance.apiInstance._components.gLegend,
      dataSet,
      chartData,
      seriesLength,
      dataLength,
      rows,
      columns,
      propertyFormatter,
      plotIndex,
      seriesIndex;
    // Make the legend accessible
    if (gLegend) {
      this.makeGradientLegendAccessible();
    } else {
      this.makeLegendAccessible();
    }

    // Make the Export accessible
    this.makeExportAccessible();

    // Get chart plot points
    dataSet = this.chartInstance.apiInstance.getDatasets();
    chartData = this.chartData.dataset;
    seriesLength = this.chartData.dataset.length;
    dataLength = this.chartData.dataset && this.chartData.dataset.length > 0 ? this.chartData.dataset[0].data.length : 0;
    rows = this.chartData.rows.row;
    columns = this.chartData.columns.column;

    // Add properties for heatmap plots
    propertyFormatter = function (i, j) {
      let plotStat = {},
        currentRow,
        currentColumn,
        dataset = this.chartData.dataset,
        rowId = dataset[i].data[j].rowid,
        columnId = dataset[i].data[j].columnid;
        // value
      plotStat['{value}'] = dataset[i].data[j].value;
      // Formatted value
      plotStat['{formattedValue}'] = this.chartInstance.formatNumber(dataset[i].data[j].value);
      // Labels for a plot
      plotStat['{topLeftLabel}'] = dataset[i].data[j].tllabel;
      plotStat['{topRightLabel}'] = dataset[i].data[j].trlabel;
      plotStat['{bottomLeftLabel}'] = dataset[i].data[j].bllabel;
      plotStat['{bottomRightLabel}'] = dataset[i].data[j].brlabel;

      currentRow = rows.find(function (row) {
        if (row.id.toUpperCase() === rowId.toUpperCase()) { return row; }
        return false;
      });

      currentColumn = columns.find(function (column) {
        if (column.id.toUpperCase() === columnId.toUpperCase()) { return column; }
        return false;
      });
      // x-axis and y-axis lables for plots
      plotStat['{yAxisLabel}'] = currentRow.label;
      plotStat['{xAxisLabel}'] = currentColumn.label;

      return plotStat;
    };

    // Tab index and aria attribute is inserted for each plot point
    for (let i = 0; i < seriesLength; i++) {
      for (let j = 0; j < dataLength; j++) {
        let plotStat = propertyFormatter.call(this, i, j);

        plotStat['{plotIndex}'] = j + 1;
        plotStat['{totalPlots}'] = dataLength;

        this.addTabIndexAndSetAria(dataSet[i].components.data[j].graphics.element && dataSet[i].components.data[j].graphics.element.node, this.alternateTexts.plot, mergeDeep(this.chartPropertyMap, plotStat), (i === 0 && j === 0) ? '2' : '-1');
      }
    }

    plotIndex = -1;
    seriesIndex = 0;
    function plotSelectOnKeyPress (event) {
      if (!this.isAllLegendItemHidden()) {
        let keyCaptured = false, elemVisible = false, limitExceeded = false,
          targetCell, newRow, currentRow, currentColumn, currentRowIndex;
        if (plotIndex !== -1) {
          // Get the current row and column id
          currentRow = chartData[seriesIndex].data[plotIndex].rowid;
          currentColumn = chartData[seriesIndex].data[plotIndex].columnid;
          currentRowIndex = rows.findIndex(function (item) {
            return (item.id === currentRow);
          });
          // currentColumnIndex = columns.findIndex(function (item) {
          //   return (item.id === currentColumn);
          // });
        }

        while (!elemVisible) {
          switch (event.keyCode) {
            case 38:
              // Up arrow
              if (currentRowIndex > 0) {
                newRow = currentRowIndex - 1;
                // eslint-disable-next-line no-loop-func
                targetCell = chartData[seriesIndex].data.findIndex(function (item) {
                  return (item.rowid === rows[newRow].id && item.columnid === currentColumn);
                });
                if (targetCell > -1) { plotIndex = targetCell; }
              }
              keyCaptured = true;
              break;
            case 40:
              // Down arrow
              if (currentRowIndex < rows.length - 1) {
                newRow = currentRowIndex + 1;
                // eslint-disable-next-line no-loop-func
                targetCell = chartData[seriesIndex].data.findIndex(function (item) {
                  return (item.rowid === rows[newRow].id && item.columnid === currentColumn);
                });
                if (targetCell > -1) { plotIndex = targetCell; }
              }
              keyCaptured = true;
              break;
            case 37:
              // left arrow
              if (plotIndex > 0) { --plotIndex; } else { limitExceeded = true; }

              keyCaptured = true;
              break;
            case 39:
              // right arrow
              if (plotIndex < dataLength - 1) { ++plotIndex; } else { limitExceeded = true; }

              keyCaptured = true;
              break;
          }

          if (keyCaptured) {
            if (limitExceeded) { break; }

            if (dataSet[seriesIndex].components.data[plotIndex].graphics.element && getComputedStyle(dataSet[seriesIndex].components.data[plotIndex].graphics.element.node).display !== 'none') {
              elemVisible = true;
            }

            if (!elemVisible && (event.keyCode === 37 || event.keyCode === 39) && this.isLegendItemHidden(seriesIndex)) {
              ++seriesIndex;
              plotIndex = -1;
            }
          } else { break; }
        }

        if (keyCaptured && elemVisible) {
          crossBrowserFocus(dataSet[seriesIndex].components.data[plotIndex].graphics.element.node);
        }
      }
    }

    // If first value of first series is focus by pressing tab then plotIndex is not updated
    // eslint-disable-next-line good-practices/no-anonymous-handler
    dataSet[0].components.data[0].graphics.element && dataSet[0].components.data[0].graphics.element.node.addEventListener('focus', function () {
      plotIndex = seriesIndex = 0;
    });

    this.svgRoot.addEventListener('keydown', plotSelectOnKeyPress.bind(this), false);
  }
}

export default FCAccessibilityHeatMap;

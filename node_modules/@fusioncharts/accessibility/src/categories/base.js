/* eslint-disable no-fallthrough */
import chartTypes from '../supportedChartTypes';
import { mergeDeep, replaceMultipleStrings, isEdge, isIE } from '../util';

const TABIndex = 'tabindex',
  TABIndexForEdge = 'tabIndex';

class FCAccessibilityBase {
  constructor (svgRoot, chartInstance, alternateTexts, config) {
    // Root SVG element
    this.svgRoot = svgRoot;

    // Instance of FusionCharts object
    this.chartInstance = chartInstance;

    // The alternate texts to be read out by screen reader
    this.alternateTexts = alternateTexts;

    // Additional configuration for accessibility
    this.config = config;

    // Chart JSON data
    this.chartData = chartInstance.getJSONData();

    // Type of the chart
    this.chartType = this.chartInstance.chartType();

    // If browser is IE
    this.isIE = isIE();

    // Key value pairs, the keys are the macros used in alternate texts and can be set by users, while the values are picked dynamically from the chart which will be replaced in place of the macros
    this.chartPropertyMap = {
      '{chartType}': (this.config && this.config.chartType) || this._getFormattedChartName(this.chartType),
      '{caption}': this.chartData.chart.caption,
      '{subcaption}': this.chartData.chart.subcaption
    };
  }

  // Get display name from chart type
  _getFormattedChartName () {
    let chartType = this.chartType;
    return chartTypes.hasOwnProperty(chartType) ? chartTypes[chartType].displayName : chartType;
  }

  /**
     * Add axis related information in chart property map
     */
  addAxisInformation () {
    this.chartPropertyMap = mergeDeep(this.chartPropertyMap, {
      '{xAxisName}': this.chartData.chart.xaxisname || '',
      '{yAxisName}': this.chartData.chart.yaxisname || ''
    });
  }

  /**
     * Add tab index and aria attribute to a SVG element
     * @param {*} elem SVG element on which tabindex and aria attributes will be applied
     * @param {*} txtToReplace Text to replace in string
     * @param {*} propertyMap Key value pair which will be used to replace macros inside a text with chart specific values
     * @param {*} tabindex Tabindex to set on the element - usually 0 or 1
     * @param {*} role Aria role to add on the element
     */
  // eslint-disable-next-line class-methods-use-this
  addTabIndexAndSetAria (elem, txtToReplace, propertyMap, tabin, role, customAttr) {
    if (elem) {
      let tabIndexText = TABIndex,
        tabindex;
      if (isEdge()) {
        // Edge browser seems to have some problem if the attribute name is tabindes
        // Edge works well with tabIndex but all other browser stops working with tabIndex
        tabIndexText = TABIndexForEdge;
      }
      tabindex = tabin || '0';
      elem.setAttribute(tabIndexText, tabindex || '0');

      // if(tabindex == "0") {
      //     elem.setAttribute('focusable', 'true');
      // }

      // For IE make all elements navigable by TAB key only, as keyboard navigation does not work for IE
      // Although focusable attribute is applied to all elements but as of now only IE works on this attribute
      // All other browser ignore the attribute as of now, hence a redundant check is ommitted to check the browser
      // If browser behavior changes with the release of SVG2 or any browser changing their own behavior, we need to update this section

      // Performing this test and enabling only for IE will make Edge browser work with Narrator flawlessly
      // But not work with JAWS
      // Hence a middle ground is followed - IE and Edge behavior is made similar by removing the check
      // if(this.isIE) {
      elem.setAttribute('focusable', 'true');
      // }

      // if(!(this.config.readerPreferenceForEdge == 'narrator' && !this.isIE)) {
      //    elem.setAttribute('focusable', 'true');
      // }

      txtToReplace && propertyMap && elem.setAttribute('aria-label', replaceMultipleStrings(txtToReplace, propertyMap));
      if (customAttr) {
        // eslint-disable-next-line guard-for-in
        for (let key in customAttr) {
          elem.setAttribute(key, customAttr[key]);
        }
      }
      role && elem.setAttribute('role', role);
    }
  }

  /**
     *
     * @param {*} elem - Element on which the aria-hidden attribute will be applied
     * @param {*} hiddenFlag - value to the aria-hidden attribute
     * @param {*} role - Aria role to add on the element
     */
  // eslint-disable-next-line class-methods-use-this
  addAriaHiddenAndRole (elem, hiddenFlag, role) {
    if (elem) {
      elem.setAttribute('aria-hidden', hiddenFlag);
      // Set Aria-role if provided
      if (role) {
        elem.setAttribute('role', role);
      }
    }
  }

  /**
     * Make a chart accessible
     * @param {*} plotEventHandler The event handler which will add all the necessary aria of all elements
     */
  makeChartAccessible (plotEventHandler) {
    let chartInstance = this.chartInstance,
      addAriaHiddenAndRole = this.addAriaHiddenAndRole,
      backButton;

    // TO-DO : Evaluate if all plot information should be included in chart aria
    // And generalize below section for all charts
    if (this.chartType === 'funnel') {
      let label, value;
      for (let i = 0; i < this.chartData.data.length; i++) {
        if (this.chartData.data[i].value) {
          label = this.chartData.data[i].label;
          value = this.chartInstance.formatNumber(this.chartData.data[i].value);
          break;
        }
      }
      this.chartPropertyMap = mergeDeep(this.chartPropertyMap, {
        '{plot-0-label}': label || '',
        '{plot-0-value}': value || ''
      });
    }

    // Span container is marked as role="region", as per WCAG 2.1 guidelines.
    this.addTabIndexAndSetAria(this.chartInstance.apiInstance.getFromEnv('chart-container'), null, null, '-1', 'region');
    this.addTabIndexAndSetAria(this.svgRoot, this.alternateTexts.chart, this.chartPropertyMap, '1');
    backButton = this.chartInstance.jsVars.overlayButton;
    /**
     *
     * @param {Object} event - Handler for back button press
     */
    function backButtonKeyPress (event) {
      event.stopPropagation();
      // eslint-disable-next-line default-case
      switch (event.keyCode) {
        case 13:
          // Enter
        case 32:
          // spacebar
          backButton.click();
          break;
      }
    }
    if (backButton) {
      this.addTabIndexAndSetAria(backButton, 'Back Button. Click this button to go back to the previous chart.', this.chartPropertyMap, '5', 'button');
      backButton.addEventListener('keydown', backButtonKeyPress.bind(this), false);
    }

    if (plotEventHandler) {
      plotEventHandler.call(this);
      // this.svgRoot.addEventListener('focus', plotEventHandler.bind(this), {once: true});
    }

    /**
     *
     * @param {Object} event - Handler to set "aria-hidden" property on tooltip
     */
    function setAriaHiddenForTooltip (value, role) {
      let tooltipElement = chartInstance.apiInstance.getFromEnv('chart-container').querySelectorAll('.fc__tooltip')[0];
      addAriaHiddenAndRole(tooltipElement, value, role);
    }

    // Adding accessibilty for tooltips when they are available
    this.chartInstance.addEventListener('dataPlotRollOver', setAriaHiddenForTooltip.bind(null, false, 'tooltip'));

    this.chartInstance.addEventListener('dataPlotRollOut', setAriaHiddenForTooltip.bind(null, true, 'tooltip'));
  }
}

export default FCAccessibilityBase;

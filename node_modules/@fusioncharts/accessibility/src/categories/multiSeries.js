/* eslint-disable one-var */
/* eslint-disable good-practices/no-single-usage-variable */
/* eslint-disable no-fallthrough */
/* eslint-disable default-case */
import { mergeDeep, crossBrowserFocus } from '../util';
import { FCAccessibilityLegendEnabled } from './legendEnabled';

let UNDEF;
class FCAccessibilityMultiSeries extends FCAccessibilityLegendEnabled {
  constructor (svgRoot, chartInstance, alternateTexts, config) {
    super(svgRoot, chartInstance, alternateTexts, config);

    this.addAxisInformation();
  }

  /**
     * Make multi series chart accessible
     */
  makeMultiSeriesAccessible (bEvent) {
    let bindEvent = bEvent,
      self = this,
      dataSet,
      categoryLength,
      seriesLength,
      dataLength;
    (bindEvent === UNDEF) && (bindEvent = true);
    !self._conf && (self._conf = {});
    // Make the legend accessible
    self.makeLegendAccessible(bindEvent);

    // Make the Export accessible
    self.makeExportAccessible();

    // Get chart plot points
    dataSet = self.chartInstance.apiInstance.getDatasets();
    categoryLength = self.chartData.categories && self.chartData.categories[0].category.length;
    seriesLength = self.chartData.dataset.length;
    dataLength = self.chartData.dataset && self.chartData.dataset.length > 0 ? self.chartData.dataset[0].data.length : 0;

    if (this.chartType === 'logmscolumn2d' || this.chartType === 'logmsline') {
      dataLength = categoryLength;
    }

    self._conf.seriesLength = seriesLength;
    self._conf.dataLength = dataLength;
    self._conf.dataSet = dataSet;

    self._conf.plotSelectOnKeyPressMS = function (event) {
      var elem = this, plotIndex, seriesIndex;
      plotIndex = +elem.getAttribute('pIndex');
      seriesIndex = +elem.getAttribute('sIndex');

      if (this.chartType === 'logmscolumn2d' || this.chartType === 'logmsline2d') {
        dataLength = categoryLength;
      }
      self._conf.dataLength = self.chartData.dataset[seriesIndex].data.length;

      if (!self.isAllLegendItemHidden()) {
        let keyCaptured = false, elemVisible = false, limitExceeded = false,
          stackedCharts = ['stackedcolumn2d', 'stackedcolumn3d'],
          arrayFound = stackedCharts.filter(function (item) { return item === self.chartInstance.chartType(); }),
          isStackedChart = arrayFound.length !== 0;
        while (!elemVisible) {
          switch (event.keyCode) {
            case 37:
              // left arrow
              if (plotIndex > 0) { --plotIndex; } else { limitExceeded = true; }

              keyCaptured = true;
              break;
            case 39:
              if (plotIndex < self._conf.dataLength - 1) { ++plotIndex; } else { limitExceeded = true; }

              keyCaptured = true;
              break;
            case 38:
              // up arrow
              // For stacked charts, up arrow will navigate to the next series
              if (seriesIndex < self._conf.seriesLength - 1 && isStackedChart) { ++seriesIndex; } else if (seriesIndex > 0 && !isStackedChart) { --seriesIndex; } else { limitExceeded = true; }

              keyCaptured = true;
              break;
            case 40:
              // down arrow
              // For stacked charts, down arrow will navigate to the previous series
              if (seriesIndex > 0 && isStackedChart) { --seriesIndex; } else if (seriesIndex < self._conf.seriesLength - 1 && !isStackedChart) { ++seriesIndex; } else { limitExceeded = true; }

              keyCaptured = true;
              break;
            case 13:
              // Enter
            case 32:
              // spacebar
              self.chartInstance.apiInstance.getDatasets()[seriesIndex]._firePlotEvent('fc-click', plotIndex < 0 ? 0 : plotIndex, new CustomEvent('click'));
              // keyCaptured = true;
              break;
          }

          if (keyCaptured) {
            if (limitExceeded) { break; }

            // if(plots[seriesIndex] && plots[seriesIndex].children && plots[seriesIndex].children.length > 0 && plots[seriesIndex].children[plotIndex] && getComputedStyle(plots[seriesIndex].children[plotIndex]).display != "none") {
            //     elemVisible = true;
            // } dataSet[i].components.data[j].graphics.element.node

            if (self._conf.dataSet[seriesIndex].components.data[plotIndex].graphics.element && getComputedStyle(self._conf.dataSet[seriesIndex].components.data[plotIndex].graphics.element.node).display !== 'none') {
              elemVisible = true;
            }

            if (!elemVisible && (event.keyCode === 37 || event.keyCode === 39) && self.isLegendItemHidden(seriesIndex)) {
              ++seriesIndex;
              plotIndex = -1;
            }
          } else { break; }
        }

        if (keyCaptured && elemVisible) {
          crossBrowserFocus(self._conf.dataSet[seriesIndex].components.data[plotIndex].graphics.element.node);
        }
      }
    };
    // All multi series chart has series name

    // Bubble chart has x,y,z value and also name of a bubble can be specified
    let bubblePlotProperties = (i, j) => {
        let plotStat = {};
        // x value of bubble
        plotStat['{xValue}'] = this.chartData.dataset[i].data[j].x || '';
        // y value of bubble
        plotStat['{yValue}'] = this.chartData.dataset[i].data[j].y || '';
        // z value of bubble
        plotStat['{zValue}'] = this.chartData.dataset[i].data[j].z || '';
        // label of the bubble
        plotStat['{bubbleName}'] = this.chartData.dataset[i].data[j].name || '';
        // Series name
        plotStat['{seriesName}'] = this.chartData.dataset[i].seriesname || '';

        return plotStat;
      },

      // Scatter chart has x and y value
      scatterPlotProperties = (i, j) => {
        let plotStat = {};
        // x value of bubble
        plotStat['{xValue}'] = this.chartData.dataset[i].data[j].x || '';
        // y value of bubble
        plotStat['{yValue}'] = this.chartData.dataset[i].data[j].y || '';
        // Series name
        plotStat['{seriesName}'] = this.chartData.dataset[i].seriesname || '';

        return plotStat;
      },

      // For all other supported multi series chart label and value is present
      defaultMultiSeriesPlotPorperties = (i, j) => {
        let plotStat = {};
        // Label
        plotStat['{label}'] = (this.chartData.categories && this.chartData.categories[0].category[j].label) || '';
        // value
        plotStat['{value}'] = this.chartData.dataset[i].data[j].value;
        // Formatted value
        plotStat['{formattedValue}'] = this.chartInstance.formatNumber(this.chartData.dataset[i].data[j].value);
        // Series
        plotStat['{seriesName}'] = this.chartData.dataset[i].seriesname || '';

        return plotStat;
      },

      // Based on the chart type, property formatter is decided
      propertyFormatter;
    switch (this.chartType) {
      case 'scatter':
        propertyFormatter = scatterPlotProperties;
        break;
      case 'bubble':
        propertyFormatter = bubblePlotProperties;
        break;
      default:
        propertyFormatter = defaultMultiSeriesPlotPorperties;
        break;
    }

    let alternateTextsPlot;

    // Tab index and aria attribute is inserted for each plot point
    for (let i = 0; i < seriesLength; i++) {
      for (let j = 0; j < dataLength; j++) {
        let plotStat = propertyFormatter.call(this, i, j);

        if (this.chartType === 'scatter') {
          dataLength = self.chartData.dataset[i].data.length;
        }
        plotStat['{plotIndex}'] = j + 1;
        plotStat['{seriesIndex}'] = i + 1;
        plotStat['{totalPlots}'] = dataLength;
        plotStat['{totalSeries}'] = seriesLength;
        alternateTextsPlot = this.alternateTexts.plot;
        if ((dataSet[i].components.data[j].config.setLink && dataSet[i].components.data[j].config.setLink !== '') || (dataSet[i].components.data[j].config.link && dataSet[i].components.data[j].config.link !== '')) {
          alternateTextsPlot += ' This is a clickable plot';
        }

        // this.addTabIndexAndSetAria(plots[i].children[j], this.alternateTexts.plot, extend(this.chartPropertyMap, plotStat), i==0 && j==0 ? "0" : "-1");
        this.addTabIndexAndSetAria(dataSet[i].components.data[j].graphics.element && dataSet[i].components.data[j].graphics.element.node, alternateTextsPlot, mergeDeep(this.chartPropertyMap, plotStat), i === 0 && j === 0 ? '2' : '-1', 'img', {
          sIndex: i,
          pIndex: j
        });
        let element = dataSet[i].components.data[j].graphics.element;
        element && element.node.removeEventListener('keydown', element.node.plotSelectOnKeyPressMS, false);
        element && (element.node.plotSelectOnKeyPressMS = self._conf.plotSelectOnKeyPressMS);
        element && element.node.addEventListener('keydown', element.node.plotSelectOnKeyPressMS, false);
      }
    }
  }
}

export default FCAccessibilityMultiSeries;

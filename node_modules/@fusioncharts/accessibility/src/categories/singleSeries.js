/* eslint-disable good-practices/no-function-dependency */
/* eslint-disable one-var */
/* eslint-disable no-fallthrough */
/* eslint-disable default-case */
import { mergeDeep, crossBrowserFocus } from '../util';
import { FCAccessibilityLegendEnabled } from './legendEnabled';
import FCAccessibilityExportEnabled from './exportEnabled';

class FCAccessibilitySingleSeries extends FCAccessibilityExportEnabled {
  // eslint-disable-next-line no-useless-constructor
  constructor (svgRoot, chartInstance, alternateTexts, config) {
    super(svgRoot, chartInstance, alternateTexts, config);
  }

  /**
   * Make single series chart accessible
   */
  makeSingleSeriesAccessible () {
    var dataLength, self = this;
    !self._conf && (self._conf = {});
    if (this.chartType === 'angulargauge') {
      dataLength = this.chartData.dials.dial.length;
    } else if (this.chartType === 'hlineargauge') {
      dataLength = this.chartData.pointers.pointer.length;
    } else if (this.chartType === 'hled' || this.chartType === 'vled' || this.chartType === 'bulb' || this.chartType === 'hbullet' || this.chartType === 'vbullet') {
      dataLength = 1;
    } else {
      dataLength = this.chartData.data.length;
    }

    // Make the Export accessible
    self.makeExportAccessible();

    let plotData;
    switch (this.chartType) {
      case 'pyramid':
      case 'funnel':
        plotData = this.chartInstance.apiInstance.getDatasets()[0]._components.data;
        break;
      default:
        plotData = this.chartInstance.apiInstance.getDatasets()[0].components.data;
        break;
    }
    self._conf.plotData = plotData;
    self._conf.dataLength = dataLength;

    self._conf.plotSelectOnKeyPressSS = function (event) {
      let elem = this,
        plotIndex = +elem.getAttribute('pIndex'),
        keyCaptured = false, elemVisible = false,
        loopCount = 0,
        plotLength = self._conf.dataLength - 1;
      if (self.chartType === 'waterfall2d') {
        plotLength = self._conf.dataLength;
      }
      while (!elemVisible && loopCount < self._conf.dataLength) {
        ++loopCount;
        switch (event.keyCode) {
          case 37:
          case 38:
            // left arrow and down arrow
            --plotIndex;
            if (plotIndex < 0) {
              plotIndex = plotLength;
            }
            keyCaptured = true;
            break;
          case 39:
          case 40:
            // right arrow and up arrow
            ++plotIndex;
            if (plotIndex > plotLength) {
              plotIndex = 0;
            }
            keyCaptured = true;
            break;
          case 13:
          // Enter
          case 32:
            // spacebar
            if (self.chartInstance.apiInstance.getDatasets()[0]._firePlotEvent) {
              self.chartInstance.apiInstance.getDatasets()[0]._firePlotEvent('fc-click', plotIndex < 0 ? 0 : plotIndex, new CustomEvent('click'));
            } else if (self.chartType === 'angulargauge') {
              if (self.chartInstance.apiInstance.getDatasets()[0].components.data[plotIndex < 0 ? 0 : plotIndex].graphics.pointersTpath.data('eventArgs')) {
                self.chartInstance.apiInstance.plotEventHandler(self.chartInstance.apiInstance.getDatasets()[0].components.data[plotIndex < 0 ? 0 : plotIndex].graphics.pointersTpath, new CustomEvent('click'));
              } else {
                self.chartInstance.apiInstance.plotEventHandler(self.chartInstance.apiInstance.getDatasets()[0].components.data[plotIndex < 0 ? 0 : plotIndex].graphics.pointersPath, new CustomEvent('click'));
              }
            } else if (self.chartType === 'funnel' || self.chartType === 'pyramid') {
              self.chartInstance.apiInstance.plotEventHandler(self.chartInstance.apiInstance.getDatasets()[0]._components.data[plotIndex < 0 ? (self.chartType === 'funnel' ? 1 : 0) : plotIndex]._graphics.trackerObj, new CustomEvent('click'));
            } else if (self.chartType === 'hlineargauge') {
              self.chartInstance.apiInstance.plotEventHandler(self.chartInstance.apiInstance.getDatasets()[0].components.data[plotIndex < 0 ? 0 : plotIndex].graphics.pointer, new CustomEvent('click'));
            }
            if (self.chartType === 'pie2d' || self.chartType === 'pie3d' || self.chartType === 'doughnut2d' || self.chartType === 'doughnut3d') {
              self.chartInstance.apiInstance.getDatasets()[0].plotGraphicClick.call(self.chartInstance.apiInstance.getDatasets()[0].components.data[plotIndex < 0 ? 0 : plotIndex].graphics.element);
            }
            // keyCaptured = true;
            break;
        }
        if (keyCaptured) {
          event.preventDefault();
          if (self._conf.plotData[plotIndex]) {
            let plotElem = getPlotElement(self._conf.plotData[plotIndex]);
            if (plotElem) {
              if (document.activeElement === plotElem.node) continue;

              crossBrowserFocus(plotElem.node);
              elemVisible = true;
            }
          }
        } else { break; }
      }
    };

    let getPlotElement = (plot) => {
        switch (this.chartType) {
          case 'pyramid':
          case 'funnel':
            return plot._graphics.graphic;
          case 'angulargauge':
            if (plot.graphics.pointersTpath.data('eventArgs')) {
              return plot.graphics.pointersTpath;
            }
            return plot.graphics.pointersPath;
          case 'hlineargauge':
            return plot.graphics.pointer;
          case 'hled':
          case 'vled':
            return plot.graphics.element.parent.parent.node.children[0];
          case 'hbullet':
          case 'vbullet':
            return plot.graphics.element.parent.parent;
          default:
            return plot.graphics.element;
        }
      },

      firstElementIndex = -1,

      // eslint-disable-next-line no-unused-vars
      addAria = (function () {
        let getPlotStats = (plotConfig, i) => {
            let plotStat = {};

            // label
            plotStat['{label}'] = plotConfig.label || plotConfig.categoryLabel || plotConfig.dataLabel || '';
            // value
            plotStat['{value}'] = plotConfig.y || plotConfig.setValue || 0;
            plotStat['{target}'] = plotConfig.target || 0;
            plotStat['{formattedValue}'] = plotConfig.formatedVal || this.chartInstance.formatNumber(plotStat['{value}']) || '';
            plotStat['{plotIndex}'] = i + 1;
            plotStat['{totalPlots}'] = plotData.length;
            plotStat['{percentValue}'] = plotConfig.pValue;

            return plotStat;
          },

          /**
       * Add aria values to a plot with given index
       *
       * There may be cases where data is null in chart data, in such cases dom is not renereded
       * i denotes the index of plot in chart data
       *
       * The correct dom index for next plot is returned from function, if the data is found to be invalid then current dom element is matched for next data
       * @param {*} i
       *
       */
          plotIterator = (i) => {
            let alternateTextsPlot;
            if (plotData[i]) {
              let plotElem = getPlotElement(plotData[i]);
              if (plotElem) {
                if (firstElementIndex === -1) firstElementIndex = i;
                let plotStats;
                if (this.chartType === 'pyramid' || this.chartType === 'funnel') {
                  plotStats = getPlotStats(plotData[i], i);
                } else {
                  plotStats = getPlotStats(plotData[i].config, i);
                }
                alternateTextsPlot = this.alternateTexts.plot;
                if ((plotData[i].config.setLink && plotData[i].config.setLink !== '') || (plotData[i].config.link && plotData[i].config.link !== '') || (plotData[i].config.dataLink && plotData[i].config.dataLink !== '') || (plotData[i].link && plotData[i].link !== '')) {
                  // eslint-disable-next-line good-practices/no-static-strings-in-scope
                  alternateTextsPlot += ' This is a clickable plot';
                }

                this.addTabIndexAndSetAria(plotElem.node || plotElem, alternateTextsPlot, mergeDeep(this.chartPropertyMap, plotStats), firstElementIndex === i ? '2' : '-1', 'img', {
                  pIndex: i
                });
                (plotElem.node || plotElem).removeEventListener('keydown', (plotElem.node || plotElem).plotSelectOnKeyPressSS, false);
                (plotElem.node || plotElem).plotSelectOnKeyPressSS = self._conf.plotSelectOnKeyPressSS;
                (plotElem.node || plotElem).addEventListener('keydown', (plotElem.node || plotElem).plotSelectOnKeyPressSS, false);
              }
            }
          };

        for (let i = 0; i < dataLength; i++) {
          plotIterator(i);
        }

        if (this.chartType === 'waterfall2d') {
          plotIterator(dataLength);
        }
      }.call(this));
  }
}

class FCAccessibilitySingleSeriesWithLegend extends FCAccessibilityLegendEnabled {
  // eslint-disable-next-line no-useless-constructor
  constructor (svgRoot, chartInstance, alternateTexts, config) {
    super(svgRoot, chartInstance, alternateTexts, config);
  }

  /**
   * Make single series chart with legend accessible
   */
  makeSingleSeriesWithLegendAccessible () {
    this.makeLegendAccessible();

    let accessibleSingleSeries = new FCAccessibilitySingleSeries(this.svgRoot, this.chartInstance, this.alternateTexts, this.config);
    accessibleSingleSeries.makeSingleSeriesAccessible();
  }
}

export { FCAccessibilitySingleSeries, FCAccessibilitySingleSeriesWithLegend };

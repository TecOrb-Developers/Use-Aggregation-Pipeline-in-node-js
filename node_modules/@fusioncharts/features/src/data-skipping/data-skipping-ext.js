"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule=true;exports.default=void 0;var _dataSkippingFilters=_interopRequireDefault(require("./data-skipping-filters"));var _dataSkippingCharts=require("./data-skipping-charts");var _lib=require("@fusioncharts/core/src/lib");var ALLOWED_RATIO_FOR_SKIPPING=1.5;var hashMapping=[],prevDataLen=0,skipConf={},dragHashMap=[];function elemHideDecider(prevDrawInfo){if(prevDrawInfo===void 0){prevDrawInfo=[]}return prevDrawInfo.filter((function(v){return!hashMapping[v]}))}function getBeforeSkippingDrawMap(_prevDataLen){if(_prevDataLen===void 0){_prevDataLen=0}return Array.from(new Array(_prevDataLen),(function(val,idx){return idx}))}function decideSkip(config){if(config===void 0){config={}}var component=config.component,type=config.compType,data,dataLen,plotPerPixelRatio,chartConfig=component.getFromEnv("chartConfig"),chartAttrs=component.getFromEnv("dataSource").chart||{},plotBinSize=(0,_lib.pluckNumber)(chartAttrs.plotbinsize,chartConfig.plotbinsize),plotsPerBin,effectiveLength;skipConf.plotBinSize=plotBinSize;skipConf.labelBinSize=(0,_lib.pluckNumber)(chartAttrs.labelbinsize,chartConfig.labelbinsize);skipConf.jsonData=component.config.JSONData;if(type==="group"){data=skipConf.jsonData[0].data;prevDataLen=component.config.stackValues&&component.config.stackValues.length||0}else if(type==="dataset"){data=skipConf.jsonData.data;prevDataLen=component.components.data&&component.components.data.length||0}dataLen=data&&data.length;hashMapping=[];skipConf.width=effectiveLength=component.getFromEnv("chart").isBar?config.height||component.getFromEnv("chartHeight"):config.width||component.getFromEnv("chartWidth");plotPerPixelRatio=dataLen/effectiveLength;plotsPerBin=Math.floor(plotPerPixelRatio*plotBinSize);if(plotPerPixelRatio>=ALLOWED_RATIO_FOR_SKIPPING&&plotsPerBin>1){skipConf.plotsPerBin=plotsPerBin;skipConf.noOfPlotBins=Math.ceil(dataLen/skipConf.plotsPerBin);return true}return false}function plotDrawIndices(filter,data){var startIndex=0,endIndex=0,plotsToBeDrawn=[];for(var i=1;i<skipConf.noOfPlotBins;++i){startIndex=endIndex;endIndex+=skipConf.plotsPerBin;filter(startIndex,endIndex-1,data,dragHashMap,plotsToBeDrawn)}filter(endIndex,data.length-1,data,dragHashMap,plotsToBeDrawn);dragHashMap=[];return plotsToBeDrawn}function labelDrawIndices(plotIndices){var labelVsPlotBinRatio=skipConf.labelBinSize/skipConf.plotBinSize,drawableLabelIndices=[],labelHashMap=[],i,len=plotIndices.length;for(i=0;i<len;i++){if(!(i%labelVsPlotBinRatio)){drawableLabelIndices.push(plotIndices[i]);labelHashMap[plotIndices[i]]=true}}return{drawableLabelIndices:drawableLabelIndices,labelHashMap:labelHashMap}}function skippingTool(config){var _filterType=_dataSkippingCharts.filterType[config.datasetType],component=config.component,prevSkipInfo=component.getSkippingInfo&&component.getSkippingInfo(),prevDrawInfo=prevSkipInfo&&prevSkipInfo.draw.slice(0),prevLabelInfo=prevSkipInfo&&(prevSkipInfo.labelDraw||[]).slice(0),skipInfo={},stackDataArray=[],i,j,sum,nDataset,labelDrawInfo,catLen=component.getFromEnv("xAxis").getTicksLen(),stackData;!(prevDrawInfo&&prevDrawInfo.length)&&(prevDrawInfo=getBeforeSkippingDrawMap(prevDataLen));!(prevLabelInfo&&prevLabelInfo.length)&&(prevLabelInfo=prevDrawInfo);dragHashMap=prevSkipInfo&&prevSkipInfo.dragHashMap;if(component.getName()==="cartesianStackGroup"){nDataset=skipConf.jsonData.length;for(i=0;i<catLen;++i){sum=0;for(j=0;j<nDataset;++j){stackData=skipConf.jsonData[j].data;sum+=Number(stackData[i]?stackData[i].value:0)}stackDataArray.push({value:sum})}skipInfo.draw=plotDrawIndices((0,_dataSkippingFilters.default)(_filterType),stackDataArray)}else{skipInfo.draw=plotDrawIndices((0,_dataSkippingFilters.default)(_filterType),skipConf.jsonData.data)}skipInfo.draw.forEach((function(element){hashMapping[element]=true}));skipInfo.drawOnlyMap=hashMapping;skipInfo.hide=elemHideDecider(prevDrawInfo);labelDrawInfo=labelDrawIndices(skipInfo.draw);skipInfo.labelDraw=labelDrawInfo.drawableLabelIndices;hashMapping=skipInfo.labelDrawOnlyMap=labelDrawInfo.labelHashMap;skipInfo.hideLabel=elemHideDecider(prevLabelInfo);skipInfo.plotsPerBin=skipConf.plotsPerBin;skipInfo.skippingApplied=true;skipInfo.dragHashMap=[];skipInfo.prevDrawInfo=prevDrawInfo.slice(0);return skipInfo}function updateDragMap(config){if(config===void 0){config={}}var component=config.component,eventArgs=config.eventArgs,skipInfo=component.getSkippingInfo&&component.getSkippingInfo()||{};eventArgs&&(skipInfo.dragHashMap[eventArgs.dataIndex]=eventArgs.endValue)}function dataSkipping(config){if(config===void 0){config={}}var component=config.component;if(decideSkip(config)){component.setSkippingInfo&&component.setSkippingInfo(skippingTool(config))}else{component.setSkippingInfo&&component.setSkippingInfo()}}var _default={dataSkipping:dataSkipping,updateDragMap:updateDragMap};exports.default=_default;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var typescript_1 = __importDefault(require("typescript"));
var path_1 = __importDefault(require("path"));
var logger_1 = __importDefault(require("../lib/logger"));
var CompilerHost = /** @class */ (function () {
    function CompilerHost(configOptions, pathHost) {
        this.configOptions = configOptions;
        this.pathHost = pathHost;
        Object.assign(this, {
            // getDefaultLibFileName: () => 'lib.d.ts',
            getDefaultLibFileName: function () {
                return path_1["default"].join(configOptions.config.root, 'node_modules/typescript/lib/lib.d.ts');
            },
            fileExists: function (fileName) { return typescript_1["default"].sys.fileExists(fileName); },
            readFile: function (fileName) { return typescript_1["default"].sys.readFile(fileName); },
            writeFile: function (fileName) { return typescript_1["default"].sys.writeFile(fileName, ''); },
            getCurrentDirectory: function () { return typescript_1["default"].sys.getCurrentDirectory(); },
            getDirectories: function (fileName) { return typescript_1["default"].sys.getDirectories(fileName); },
            getCanonicalFileName: function (fileName) {
                return typescript_1["default"].sys.useCaseSensitiveFileNames ? fileName : fileName.toLowerCase();
            },
            getNewLine: function () { return typescript_1["default"].sys.newLine; },
            useCaseSensitiveFileNames: function () { return typescript_1["default"].sys.useCaseSensitiveFileNames; }
        });
    }
    CompilerHost.prototype.getSourceFile = function (fileName, languageVersion) {
        var sourceText = typescript_1["default"].sys.readFile(fileName);
        var changedPathsSourceText;
        if (!fileName.includes('node_modules')) {
            logger_1["default"].info('get source file', fileName);
            // it can modify emit source text at this
            logger_1["default"].log('source text', fileName, sourceText);
            // 只能在此处修改路径引用，不能直接修改source file ast的imports[0].text的路径，会导致虚拟树紊乱
            // sourceText = sourceText.replace('@test/b', '@test/ctest');
            var imports = this.collectExternalModuleReferences(typescript_1["default"].createSourceFile(fileName, sourceText, languageVersion));
            changedPathsSourceText = this.pathHost.changeModulePaths(fileName, sourceText, imports, 'relative');
            logger_1["default"].info('[after change module paths sourceText]', changedPathsSourceText);
            logger_1["default"].log('create source file', imports, fileName);
        }
        return sourceText !== undefined
            ? typescript_1["default"].createSourceFile(fileName, changedPathsSourceText || sourceText, languageVersion)
            : undefined;
    };
    CompilerHost.prototype.collectExternalModuleReferences = function (file) {
        var imports = [];
        for (var _i = 0, _a = file.statements; _i < _a.length; _i++) {
            var node = _a[_i];
            // eslint-disable-next-line
            collectModuleReferences(node, /*inAmbientModule*/ false);
        }
        return imports;
        function collectModuleReferences(node, inAmbientModule) {
            var typescript = typescript_1["default"];
            if (typescript.isAnyImportOrReExport(node)) {
                var moduleNameExpr = typescript.getExternalModuleName(node);
                // TypeScript 1.0 spec (April 2014): 12.1.6
                // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference other external modules
                // only through top - level external module names. Relative external module names are not permitted.
                if (moduleNameExpr &&
                    typescript_1["default"].isStringLiteral(moduleNameExpr) &&
                    moduleNameExpr.text &&
                    (!inAmbientModule ||
                        !typescript_1["default"].isExternalModuleNameRelative(moduleNameExpr.text))) {
                    imports = typescript.append(imports, moduleNameExpr);
                }
            }
            else if (typescript_1["default"].isModuleDeclaration(node)) {
                if (typescript.isAmbientModule(node) &&
                    (inAmbientModule ||
                        typescript.hasModifier(node, 2 /* Ambient */) ||
                        file.isDeclarationFile)) {
                    // const nameText = typescript.getTextOfIdentifierOrLiteral(node.name);
                    // Ambient module declarations can be interpreted as augmentations for some existing external modules.
                    // This will happen in two cases:
                    // - if current file is external module then module augmentation is a ambient module declaration defined in the top level scope
                    // - if current file is not external module then module augmentation is an ambient module declaration with non-relative module name
                    //   immediately nested in top level ambient module declaration .
                    // if (
                    //   isExternalModuleFile ||
                    //   (inAmbientModule && !ts.isExternalModuleNameRelative(nameText))
                    // ) {
                    //   (moduleAugmentations || (moduleAugmentations = [])).push(node.name);
                    // } else if (!inAmbientModule) {
                    //   if (file.isDeclarationFile) {
                    //     // for global .d.ts files record name of ambient module
                    //     (ambientModules || (ambientModules = [])).push(nameText);
                    //   }
                    //   // An AmbientExternalModuleDeclaration declares an external module.
                    //   // This type of declaration is permitted only in the global module.
                    //   // The StringLiteral must specify a top - level external module name.
                    //   // Relative external module names are not permitted
                    //   // NOTE: body of ambient module is always a module block, if it exists
                    //   const body = node.body;
                    //   if (body) {
                    //     for (let _i = 0, _a = body.statements; _i < _a.length; _i++) {
                    //       const statement = _a[_i];
                    //       collectModuleReferences(statement, /*inAmbientModule*/ true);
                    //     }
                    //   }
                    // }
                }
            }
        }
    };
    CompilerHost.prototype.resolveModuleNames = function (moduleNames, containingFile) {
        logger_1["default"].log('resolve modulenames', moduleNames);
        var resolvedModules = [];
        // console.log('[normal]', this.pathHost.fast2absolute(moduleNames), moduleNames);
        // moduleNames[0] = moduleNames[0].replace('@', './');
        for (var _b = 0, moduleNames_1 = moduleNames; _b < moduleNames_1.length; _b++) {
            var moduleName = moduleNames_1[_b];
            // try to use standard resolution
            var result = typescript_1["default"].resolveModuleName(moduleName, containingFile, this.configOptions.tsconfig.compilerOptions, {
                fileExists: this.fileExists,
                readFile: this.readFile
            });
            if (result.resolvedModule) {
                logger_1["default"].log('resolve module', result.resolvedModule, moduleName);
                resolvedModules.push(result.resolvedModule);
            }
            else {
                // check fallback locations, for simplicity assume that module at location
                // should be represented by '.d.ts' file
                // if (moduleName.includes('es')) {
                //   const modulePath = path.join('lib.' + moduleName + '.d.ts');
                //   if (fileExists(modulePath)) {
                //     resolvedModules.push({ resolvedFileName: modulePath });
                //   }
                // } else {
                // for (const location of moduleSearchLocations) {
                //   const modulePath = path.join(location, moduleName + '.d.ts');
                //   if (fileExists(modulePath)) {
                //     resolvedModules.push({ resolvedFileName: modulePath });
                //   }
                // }
                // }
            }
        }
        return resolvedModules;
    };
    return CompilerHost;
}());
exports["default"] = CompilerHost;

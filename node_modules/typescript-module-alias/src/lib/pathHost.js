"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var path_1 = __importDefault(require("path"));
var logger_1 = __importDefault(require("./logger"));
var PathHost = /** @class */ (function () {
    function PathHost(_a) {
        var baseUrl = _a.baseUrl, paths = _a.paths;
        this.baseUrl = baseUrl;
        this.paths = paths;
        this.fastWayPaths = this.transformConfigPaths(baseUrl, paths);
    }
    PathHost.prototype.getHeadReg = function (oldRegStr) {
        return new RegExp("^(" + oldRegStr + ")");
    };
    PathHost.prototype.clearAllMatchMark = function (str) {
        return str.replace('*', '');
    };
    PathHost.prototype.fast2absoluteWithModules = function (modulePaths) {
        var _this = this;
        return modulePaths.map(function (modulePath) { return _this.fast2absoluteWithModule(modulePath); });
    };
    PathHost.prototype.fast2absoluteWithModule = function (modulePath) {
        var _this = this;
        var match = {};
        Object.keys(this.fastWayPaths).forEach(function (fastPath) {
            if (match.value)
                return;
            var regStr = _this.getHeadReg(fastPath);
            var matchModulePath = new RegExp(regStr).exec(modulePath);
            match.value = matchModulePath && matchModulePath[0];
            if (match.value) {
                match.mapPath = _this.clearAllMatchMark(_this.fastWayPaths[fastPath][0]);
            }
        });
        if (match.value) {
            var replaceReg = this.getHeadReg(match.value);
            return path_1["default"].join(match.mapPath, modulePath.replace(replaceReg, ''));
        }
        return modulePath;
    };
    PathHost.prototype.fast2relate = function (modulePaths) {
        return modulePaths.map(function (modulePath) {
            return modulePath;
        });
    };
    PathHost.prototype.transformRequirePath = function (code, outputRelate) {
        var matchRequirePathReg = /require\(["']([\w\-\.\@~\/]+)["']\)/;
        var matchRequirePathRegAll = /require\(["']([\w\-\.\@~\/]+)["']\)/g;
        var allRequires = code.match(matchRequirePathRegAll);
        var matchPathStack = [];
        allRequires.forEach(function (requireStr) {
            var matchParts = requireStr.match(matchRequirePathReg);
            // get match path
            // for example: require('@test/b') => @test/b
            var matchPath = matchParts[1];
            matchPathStack.push(matchPath);
        });
        var outputPath;
        if (!outputRelate) {
            outputPath = this.fast2absoluteWithModules(matchPathStack);
        }
        else {
            outputPath = this.fast2relate(matchPathStack);
        }
        matchPathStack.forEach(function (matchPath, i) {
            code = code.replace(matchPath, outputPath[i]);
        });
    };
    PathHost.prototype.transformConfigPaths = function (baseUrl, paths) {
        var absolutePaths = {};
        Object.keys(paths).forEach(function (fastWay) {
            var relatePathValue = [];
            paths[fastWay].forEach(function (relatePath) {
                relatePathValue.push(path_1["default"].join(baseUrl, relatePath));
            });
            absolutePaths[fastWay] = relatePathValue;
        });
        return absolutePaths;
    };
    /**
     * change module paths for file external modules
     * @param {*} sourceText file source text
     * @param {*} imports import modules array with this file
     * @param {*} outputType the type of output external module path, for example: 'relative' | 'absolute'
     */
    PathHost.prototype.changeModulePaths = function (fileName, sourceText, imports, outputType) {
        for (var i = 0; i < imports.length; i++) {
            // if imports.length > 1, splice front external module path
            // then need change next external pos and end prop #todo
            var oldPos = imports[i].pos + 1;
            var oldEnd = imports[i].end;
            logger_1["default"].log('will be replaced text', sourceText.slice(oldPos, oldEnd));
            var absolutePath = this.fast2absoluteWithModule(imports[i].text);
            // if the old import path is relative path, then don't need transform
            if (!path_1["default"].isAbsolute(absolutePath)) {
                continue;
            }
            var replacePath = void 0;
            if (outputType === 'absolute') {
                replacePath = absolutePath;
            }
            else if (outputType === 'relative') {
                logger_1["default"].log('[absolutePath]', absolutePath);
                replacePath = this.getRelativeBetween2AbsolutePath(fileName, absolutePath);
            }
            var changeLen = replacePath.length - imports[i].text.length;
            var sourceTextParts = [
                sourceText.slice(0, oldPos),
                "'" + replacePath + "'",
                sourceText.slice(oldEnd)
            ];
            sourceText = sourceTextParts.join('');
            this.changeOtherImportsPos(i, changeLen, imports);
        }
        return sourceText;
    };
    PathHost.prototype.getRelativeBetween2AbsolutePath = function (fileName, importPath) {
        var currDir = path_1["default"].dirname(fileName);
        var strHeap = currDir.split('');
        // computed between fileName and importPath common dir prefix
        var end = 0;
        for (var i = 0; i < strHeap.length; i++) {
            if (importPath[i] === strHeap[i]) {
                end = i;
            }
            else {
                break;
            }
        }
        var oldMatchDir = currDir.slice(0, end + 1);
        var realMatchDir = oldMatchDir.split('/').slice(0, -1).join('/') + '/';
        end = realMatchDir.length - 1;
        logger_1["default"].log('matchdir', oldMatchDir, realMatchDir, currDir);
        if (end === currDir.length - 1) {
            // The path to be imported is in the current directory
            return importPath.replace(this.getHeadReg(currDir), '.');
        }
        else {
            // The path to be imported is out the current directory
            // The path separator of window system is\, need according to different systems to split
            // Mac os is /, window is \
            var replacedMatchPart = fileName.replace(this.getHeadReg(realMatchDir), '');
            // If go out, real layers show be reduced 1
            var goOutLayers = replacedMatchPart.split('/').length - 1;
            var layersStr = '';
            for (var i = 0; i < goOutLayers; i++) {
                layersStr += '../';
            }
            // clear tail separator
            return layersStr + importPath.replace(this.getHeadReg(realMatchDir), '');
        }
    };
    PathHost.prototype.changeOtherImportsPos = function (index, changeLen, imports) {
        // change from next import part
        for (var i = index + 1; i < imports.length; i++) {
            var oldPos = imports[i].pos;
            var oldEnd = imports[i].end;
            imports[i].pos = oldPos + changeLen;
            imports[i].end = oldEnd + changeLen;
        }
    };
    PathHost.prototype.fast2absoluteWithAst = function (sourceText, sourceFile) {
        var imports = sourceFile.imports;
        if (!imports)
            return sourceText;
        for (var i = 0; i < imports.length; i++) {
            var importAst = imports[i];
            var replacedPath = this.fast2absoluteWithModule(importAst.text);
            logger_1["default"].log('replacePath', replacedPath);
            // sourceText = sourceText.splice(importAst.pos, importAst.end, replacedPath);
        }
    };
    return PathHost;
}());
exports["default"] = PathHost;
